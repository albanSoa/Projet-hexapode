// Importation de la bibliothèque pour communiquer avec Arduino via le port série
import processing.serial.*;
Serial port; // Objet pour gérer la communication série

// Coordonnées du centre de l'écran (utilisé pour dessiner les flèches directionnelles)
float centreX = 450;
float centreY = 275;

// Variables pour le curseur vertical (type de slider)
float curseurY; // Position verticale du curseur
float curseurX = 265; // Position horizontale du curseur
float curseurHaut = 200; // Limite supérieure du curseur
float curseurBas = 310; // Limite inférieure du curseur
boolean glissementCurseur = false; // Indique si l'utilisateur est en train de déplacer le curseur

// Variables pour les directions du robot
boolean avancer = false;
boolean reculer = false;

void setup() {
  // Initialisation de la fenêtre graphique
  size(900, 550); // Taille de la fenêtre
  frameRate(60); // Nombre d'images par seconde
  ellipseMode(CENTER); // Mode de dessin des cercles
  textFont(createFont("Arial", 12)); // Police de texte
  textAlign(CENTER, CENTER); // Alignement du texte
  port = new Serial(this, Serial.list()[0], 9600); // Connexion au premier port série disponible
  textSize(20); // Taille du texte
  curseurY = curseurBas; // Position initiale du curseur
}

void draw() {
  // Fonction appelée en boucle pour dessiner l'interface
  background(255); // Fond blanc

  // Dessiner fond d'écran
  dessinerBack();
  // Dessin des boutons interactifs
  dessinerBouton("Coucou", 30, 175);
  dessinerBouton("Position initiale", 30, 275);
  dessinerBouton("Repousser Obj", 750, 275);
  dessinerBouton("Tremble", 750, 175);


  // Dessin des flèches directionnelles
  dessinerFlechesDirectionnelles();

  // Dessin du curseur vertical
  dessinerCurseurVertical();

  // Envoi des commandes au robot selon les touches activées
  if (avancer) port.write("Avancer\n");
  if (reculer) port.write("Reculer\n");
}

void dessinerBouton(String texte, int x, int y) {
  // Dessine un bouton avec texte à la position (x, y)
  int largeur = 120;
  int hauteur = 40;
  boolean survol = mouseX > x && mouseX < x + largeur && mouseY > y && mouseY < y + hauteur;

  // Ombre du bouton
  fill(180, 180, 180, 80);
  noStroke();
  rect(x + 3, y + 3, largeur, hauteur, 10);

  // Couleur du bouton selon survol
  fill(survol ? color(70, 130, 255) : color(200));
  stroke(60);
  strokeWeight(1);
  rect(x, y, largeur, hauteur, 10);

  // Texte du bouton
  fill(survol ? 255 : 0);
  textAlign(CENTER, CENTER);
  textSize(14);
  text(texte, x + largeur / 2, y + hauteur / 2);
}

void dessinerBack(){
  fill(108, 97, 186);
  circle(280, 257, 200);
  circle(610, 257, 200);
  rect(280, 165, 330, 185, 28);
  
  
  fill(222, 222, 222);
  circle(610, 257, 150);
  
  // boutons ronds
  fill(0);
  circle(610, 220, 35);
  circle(610, 300, 35);
  circle(570, 260, 35);
  circle(650, 260, 35);
  
  
  
  
  // Texte
  fill(0);
  textAlign(CENTER);
  textSize(30);
  text("MANETTE DE L'HEXAPODE",450,50);
}

void dessinerFlechesDirectionnelles() {
  // Dessine les flèches pour les directions
  dessinerFlecheHaut(width/2, 220, "Avancer", 0);
  dessinerFlecheBas(width/2, 315, "Reculer", PI);
  dessinerFleche(220, 260, -HALF_PI);
  dessinerFleche(310, 260, HALF_PI);
}

void dessinerFleche(float x, float y, float rotation) {
  // Dessine une flèche orientée selon rotation
  pushMatrix();
  translate(x, y);
  rotate(rotation);
  fill(0);
  stroke(0);
  triangle(-20, 20, 20, 20, 0, -20); // Forme de la flèche
  popMatrix();
}


void dessinerFlecheHaut(float x, float y, String etiquette, float rotation) {
  // Dessine une flèche orientée selon rotation
  pushMatrix();
  translate(x, y);
  rotate(rotation);
  fill(0);
  stroke(0);
  triangle(-10, 10, 10, 10, 0, -20); // Forme de la flèche
  popMatrix();
  fill(0);
  text(etiquette, x, y + 25); // Texte sous la flèche
  fill(255);
  text("z", x, y); // Texte sous la flèche
}

void dessinerFlecheBas(float x, float y, String etiquette, float rotation) {
  // Dessine une flèche orientée selon rotation
  pushMatrix();
  translate(x, y);
  rotate(rotation);
  fill(0);
  stroke(0);
  triangle(-10, 10, 10, 10, 0, -20); // Forme de la flèche
  popMatrix();
  fill(0);
  text(etiquette, x, y - 25); // Texte sur la flèche
  fill(255);
  text("s", x, y); // Texte sous la flèche
}

void dessinerCurseurVertical() {
  // Dessine un curseur vertical (slider)
  stroke(150);
  strokeWeight(20);
  line(curseurX, curseurHaut, curseurX, curseurBas); // Ligne du curseur

  fill(100);
  noStroke();
  ellipse(curseurX, curseurY, 20, 20); // Bouton du curseur

  // Affiche la valeur du curseur
  float valeur = map(curseurY, curseurBas, curseurHaut, 0, 5);
  port.write(int(valeur) + "\n");
  fill(0);
  textAlign(LEFT, CENTER);
  textSize(14);
  text("Valeur : " + int(valeur), curseurX + 30, curseurY);
}

void mouseDragged() {
  // Si le curseur est en train d'être déplacé
  if (glissementCurseur) {
    curseurY = constrain(mouseY, curseurHaut, curseurBas); // Limite le déplacement
  }
}

void mousePressed() {
    // Flèche "Avancer"
  if (mouseX > width/2 - 20 && mouseX < width/2 + 20 && mouseY > 150 - 20 && mouseY < 150 + 20) {
    avancer = true;
    port.write("Avancer\n");
  }

    // Flèche "Reculer"
  if (mouseX > width/2 - 20 && mouseX < width/2 + 20 && mouseY > 245 - 20 && mouseY < 245 + 20) {
    reculer = true;
    port.write("Reculer\n");
  }

  // Si clic sur le bouton "Coucou"
  if (mouseX > 30 && mouseX < 160 && mouseY > 175 && mouseY < 210) {
    port.write("coucou\n");
    delay(650);
    port.write("Position initiale\n");
  }

  // Si clic sur "Position initiale"
  if (mouseX > 30 && mouseX < 160 && mouseY > 275 && mouseY < 310) {
    port.write("Position initiale\n");
  }

  // Si clic sur "Repousser Obj"
  if (mouseX > 720 && mouseX < 840 && mouseY > 275 && mouseY < 310) {
    port.write("Oscille\n");
    delay(2500);
    port.write("Oscille\n");
    delay(2500);
    port.write("Position initiale\n");
  }

  // Si clic sur "Tremble"
  if (mouseX > 720 && mouseX < 840 && mouseY > 175 && mouseY < 210) {
    for (int i = 0; i < 6; i++) {
      port.write("Tremble\n");
      delay(90);
    }
  }

  // Si clic sur le curseur
  if (dist(mouseX, mouseY, curseurX, curseurY) < 10) {
    glissementCurseur = true;
  }
}


void keyPressed() {
  // Quand une touche est pressée, on active la direction correspondante
  if (key == 'z' || key == 'Z') {
    avancer = true;
    println("Avancer");
  }
  if (key == 's' || key == 'S') {
    reculer = true;
    println("Reculer");
  }
}

void keyReleased() {
  // Quand une touche est relâchée, on arrête le mouvement et remet en position initiale
  if (key == 'z' || key == 'Z') {
    avancer = false;
    port.write("Position initiale\n");
  }
  if (key == 's' || key == 'S') {
    reculer = false;
    port.write("Position initiale\n");
  }
}
